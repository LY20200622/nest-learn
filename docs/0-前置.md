# 前置

## 1 控制反转/依赖注入

> Nest 是围绕 **依赖注入** 构建的

### 1.1 依赖注入

即 Dependency Injection 或者 DI。此系统中有两种角色：**依赖提供者** 和 **依赖消费者**。二者通过 **注入器** 的进行交互。当一个依赖被请求的时候，**注入器** 会检查它的注册表中是否有对应的依赖实例，若有返回，若没有则会创建一个实例并储存在 **注入器** 的注册表中

### 1.2 控制反转

即 Inversion of Control 或者 IoC。在非反转的情况下，对象的创建由自己把控（例如：通过 new 方式），使用完之后也是自己去销毁，这样就导致对象始终会与其他类耦合在一起。在有反转容器 IOC 后，当需要某个对象时，不再需要手动创建，而只需要告诉 IOC 容器，然后 IOC 容器就会帮助完成创建。组件对象的控制权由程序代码本身转移到了外部容器，这即是反转

### 1.3 二者的关系

控制反转是一种软件设计原则，依赖注入是实现控制反转的一种具体方式

## 2 面向切面编程

> Nest 内置有一个 **控制反转容器**，用于实现依赖注入。

即 Aspect-Oriented Programming 或者 AOP。一般情况下，业务设计是纵向设计且不互通，例如：购买相关业务模块和锻炼相关业务模块。但类似日志这样的通用业务，可能需要横跨多个模块被使用，这样就需要使用面向切面编程。面向切面编程就是将这类与核心业务无关的，但又影响着多个类的公共行为抽取、封装到一个可重用模块，从而实现代码复用和模块解耦的目的

### 2.1 关注点

AOP 将软件系统划分成了 **核心关注点** 和 **横切关注点**。业务的核心功能则为 **核心关注点**，与业务无关或者关系不大的则为 **横切关注点**

### 2.2 AOP 类型

AOP 框架本质就是对目标对象源代码修改，生成具有新功能的代理对象，根据对目标对象源代码的修改时机，可以将 AOP 框架划分为以下两大类：

#### 2.2.1 静态 AOP

采用了这种方案的 AOP 框架会在编译阶段对程序的需要增强的代码进行修改，从而生成静态的 AOP 代理类，即这样实际上编译出来的类的 class 文件实际上已经是增强后的代理类，因为编译期的特殊性，所以要实现静态 AOP 需要用特殊的编译器

#### 2.2.2 动态 AOP

采用这种方案的 AOP 框架是在运行时才会对目标对象生成代理对象
